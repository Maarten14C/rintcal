<!DOCTYPE html><html><head><title>R: Convert R objects to/from JSON</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table style="width: 100%;"><tr><td>toJSON, fromJSON {jsonlite}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2 id='toJSON+2C+20fromJSON'>Convert <span class="rlang"><b>R</b></span> objects to/from JSON</h2>

<h3>Description</h3>

<p>These functions are used to convert between JSON data and <span class="rlang"><b>R</b></span> objects. The <code><a href="../../jsonlite/help/toJSON.html">toJSON()</a></code> and <code><a href="../../jsonlite/help/fromJSON.html">fromJSON()</a></code>
functions use a class based mapping, which follows conventions outlined in this paper:  <a href="https://arxiv.org/abs/1403.2805">https://arxiv.org/abs/1403.2805</a> (also available as vignette).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fromJSON(
  txt,
  simplifyVector = TRUE,
  simplifyDataFrame = simplifyVector,
  simplifyMatrix = simplifyVector,
  flatten = FALSE,
  ...
)

toJSON(
  x,
  dataframe = c("rows", "columns", "values"),
  matrix = c("rowmajor", "columnmajor"),
  Date = c("ISO8601", "epoch"),
  POSIXt = c("string", "ISO8601", "epoch", "mongo"),
  factor = c("string", "integer"),
  complex = c("string", "list"),
  raw = c("base64", "hex", "mongo", "int", "js"),
  null = c("list", "null"),
  na = c("null", "string"),
  auto_unbox = FALSE,
  digits = 4,
  pretty = FALSE,
  force = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toJSON+2C+20fromJSON_:_txt">txt</code></td>
<td>
<p>a JSON string, URL or file</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_simplifyVector">simplifyVector</code></td>
<td>
<p>coerce JSON arrays containing only primitives into an atomic vector</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_simplifyDataFrame">simplifyDataFrame</code></td>
<td>
<p>coerce JSON arrays containing only records (JSON objects) into a data frame</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_simplifyMatrix">simplifyMatrix</code></td>
<td>
<p>coerce JSON arrays containing vectors of equal mode and dimension into matrix or array</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_flatten">flatten</code></td>
<td>
<p>automatically <code><a href="../../jsonlite/help/flatten.html">flatten()</a></code> nested data frames into a single non-nested data frame</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_...">...</code></td>
<td>
<p>arguments passed on to class specific <code>print</code> methods</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_x">x</code></td>
<td>
<p>the object to be encoded</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_dataframe">dataframe</code></td>
<td>
<p>how to encode data.frame objects: must be one of 'rows', 'columns' or 'values'</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_matrix">matrix</code></td>
<td>
<p>how to encode matrices and higher dimensional arrays: must be one of 'rowmajor' or 'columnmajor'.</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_Date">Date</code></td>
<td>
<p>how to encode Date objects: must be one of 'ISO8601' or 'epoch'</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_POSIXt">POSIXt</code></td>
<td>
<p>how to encode POSIXt (datetime) objects: must be one of 'string', 'ISO8601', 'epoch' or 'mongo'</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_factor">factor</code></td>
<td>
<p>how to encode factor objects: must be one of 'string' or 'integer'</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_complex">complex</code></td>
<td>
<p>how to encode complex numbers: must be one of 'string' or 'list'</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_raw">raw</code></td>
<td>
<p>how to encode raw objects: must be one of 'base64', 'hex' or 'mongo'</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_null">null</code></td>
<td>
<p>how to encode NULL values within a list: must be one of 'null' or 'list'</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_na">na</code></td>
<td>
<p>how to print NA values: must be one of 'null' or 'string'. Defaults are class specific</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_auto_unbox">auto_unbox</code></td>
<td>
<p>automatically <code><a href="../../jsonlite/help/unbox.html">unbox()</a></code> all atomic vectors of length 1. It is usually safer to avoid this and instead use the <code><a href="../../jsonlite/help/unbox.html">unbox()</a></code> function to unbox individual elements.
An exception is that objects of class <code>AsIs</code> (i.e. wrapped in <code><a href="../../base/html/AsIs.html">I()</a></code>) are not automatically unboxed. This is a way to mark single values as length-1 arrays.</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_digits">digits</code></td>
<td>
<p>max number of decimal digits to print for numeric values. Use <code><a href="../../base/html/AsIs.html">I()</a></code> to specify significant digits. Use <code>NA</code> for max precision.</p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_pretty">pretty</code></td>
<td>
<p>adds indentation whitespace to JSON output. Can be TRUE/FALSE or a number specifying the number of spaces to indent. See <code><a href="../../jsonlite/help/prettify.html">prettify()</a></code></p>
</td></tr>
<tr><td><code id="toJSON+2C+20fromJSON_:_force">force</code></td>
<td>
<p>unclass/skip objects of classes with no defined JSON mapping</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="../../jsonlite/help/toJSON.html">toJSON()</a></code> and <code><a href="../../jsonlite/help/fromJSON.html">fromJSON()</a></code> functions are drop-in replacements for the identically named functions
in packages <code>rjson</code> and <code>RJSONIO</code>. Our implementation uses an alternative, somewhat more consistent mapping
between <span class="rlang"><b>R</b></span> objects and JSON strings.
</p>
<p>The <code><a href="../../jsonlite/help/serializeJSON.html">serializeJSON()</a></code> and <code><a href="../../jsonlite/help/unserializeJSON.html">unserializeJSON()</a></code> functions in this package use an
alternative system to convert between <span class="rlang"><b>R</b></span> objects and JSON, which supports more classes but is much more verbose.
</p>
<p>A JSON string is always unicode, using <code>UTF-8</code> by default, hence there is usually no need to escape any characters.
However, the JSON format does support escaping of unicode characters, which are encoded using a backslash followed by
a lower case <code>"u"</code> and 4 hex characters, for example: <code>"Z\u00FCrich"</code>. The <code>fromJSON</code> function
will parse such escape sequences but it is usually preferable to encode unicode characters in JSON using native
<code>UTF-8</code> rather than escape sequences.
</p>


<h3>References</h3>

<p>Jeroen Ooms (2014). The <code>jsonlite</code> Package: A Practical and Consistent Mapping Between JSON Data and <span class="rlang"><b>R</b></span> Objects. <em>arXiv:1403.2805</em>. <a href="https://arxiv.org/abs/1403.2805">https://arxiv.org/abs/1403.2805</a>
</p>


<h3>See Also</h3>

<p><code><a href="../../jsonlite/help/read_json.html">read_json()</a></code>, <code><a href="../../jsonlite/help/stream_in.html">stream_in()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Stringify some data
jsoncars &lt;- toJSON(mtcars, pretty=TRUE)
cat(jsoncars)

# Parse it back
fromJSON(jsoncars)

# Parse escaped unicode
fromJSON('{"city" : "Z\\u00FCrich"}')

# Decimal vs significant digits
toJSON(pi, digits=3)
toJSON(pi, digits=I(3))

## Not run: 
#retrieve data frame
data1 &lt;- fromJSON("https://api.github.com/users/hadley/orgs")
names(data1)
data1$login

# Nested data frames:
data2 &lt;- fromJSON("https://api.github.com/users/hadley/repos")
names(data2)
names(data2$owner)
data2$owner$login

# Flatten the data into a regular non-nested dataframe
names(flatten(data2))

# Flatten directly (more efficient):
data3 &lt;- fromJSON("https://api.github.com/users/hadley/repos", flatten = TRUE)
identical(data3, flatten(data2))

## End(Not run)
</code></pre>

<hr /><div style="text-align: center;">[Package <em>jsonlite</em> version 1.8.7 <a href="00Index.html">Index</a>]</div>
</div>
</body></html>
